// Generated by @wagmi/cli@0.1.14 on 4/5/2023 at 7:38:56 PM
import {
  UseContractConfig,
  UseContractEventConfig,
  UseContractReadConfig,
  UseContractWriteConfig,
  UsePrepareContractWriteConfig,
  useContract,
  useContractEvent,
  useContractRead,
  useContractWrite,
  usePrepareContractWrite,
} from 'wagmi'
import { PrepareWriteContractResult, ReadContractResult, WriteContractMode } from 'wagmi/actions'

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Delegatable
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const delegatableABI = [
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat[]',
        type: 'tuple[]',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat',
        type: 'tuple',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_DELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATIONS_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation',
        type: 'tuple',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct ReplayProtection',
        type: 'tuple',
        components: [
          { name: 'nonce', internalType: 'uint256', type: 'uint256' },
          { name: 'queue', internalType: 'uint256', type: 'uint256' },
        ],
      },
    ],
    name: 'GET_REPLAYPROTECTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_TRANSACTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'batch',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'contractInvoke',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'domainHash', outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }] },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'delegation',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'getDelegationTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      { name: 'contractName', internalType: 'string', type: 'string' },
      { name: 'version', internalType: 'string', type: 'string' },
      { name: 'chainId', internalType: 'uint256', type: 'uint256' },
      { name: 'verifyingContract', internalType: 'address', type: 'address' },
    ],
    name: 'getEIP712DomainHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'invocations',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'getInvocationsTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'intendedSender', internalType: 'address', type: 'address' },
      { name: 'queue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'getNonce',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocations',
        internalType: 'struct SignedInvocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'invoke',
    outputs: [{ name: 'success', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyDelegationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocation',
        internalType: 'struct SignedInvocation',
        type: 'tuple',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyInvocationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ERC20Manager
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const erc20ManagerABI = [
  { stateMutability: 'nonpayable', type: 'constructor', inputs: [] },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'previousOwner', internalType: 'address', type: 'address', indexed: true },
      { name: 'newOwner', internalType: 'address', type: 'address', indexed: true },
    ],
    name: 'OwnershipTransferred',
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat[]',
        type: 'tuple[]',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat',
        type: 'tuple',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_DELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATIONS_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation',
        type: 'tuple',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct ReplayProtection',
        type: 'tuple',
        components: [
          { name: 'nonce', internalType: 'uint256', type: 'uint256' },
          { name: 'queue', internalType: 'uint256', type: 'uint256' },
        ],
      },
    ],
    name: 'GET_REPLAYPROTECTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_TRANSACTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: '_token', internalType: 'address', type: 'address' },
      { name: '_from', internalType: 'address', type: 'address' },
      { name: '_amount', internalType: 'uint256', type: 'uint256' },
      { name: '_deadline', internalType: 'uint256', type: 'uint256' },
      { name: 'v', internalType: 'uint8', type: 'uint8' },
      { name: 'r', internalType: 'bytes32', type: 'bytes32' },
      { name: 's', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'approveTransferProxy',
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'batch',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'contractInvoke',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'domainHash', outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }] },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'delegation',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'getDelegationTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      { name: 'contractName', internalType: 'string', type: 'string' },
      { name: 'version', internalType: 'string', type: 'string' },
      { name: 'chainId', internalType: 'uint256', type: 'uint256' },
      { name: 'verifyingContract', internalType: 'address', type: 'address' },
    ],
    name: 'getEIP712DomainHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_delegation',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
      { name: '_domainHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'getExternalDelegationTypedDataHash',
    outputs: [{ name: 'sigHash', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'invocations',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'getInvocationsTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'intendedSender', internalType: 'address', type: 'address' },
      { name: 'queue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'getNonce',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocations',
        internalType: 'struct SignedInvocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'invoke',
    outputs: [{ name: 'success', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: '_signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'isRevoked',
    outputs: [{ name: 'revoked', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'owner', outputs: [{ name: '', internalType: 'address', type: 'address' }] },
  { stateMutability: 'nonpayable', type: 'function', inputs: [], name: 'renounceOwnership', outputs: [] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: '_signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'revoke',
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [{ name: 'newOwner', internalType: 'address', type: 'address' }],
    name: 'transferOwnership',
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: '_token', internalType: 'address', type: 'address' },
      { name: '_to', internalType: 'address', type: 'address' },
      { name: '_amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferProxy',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyDelegationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: '_signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
      { name: '_domainHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'verifyExternalDelegationSignature',
    outputs: [{ name: 'signer', internalType: 'address', type: 'address' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocation',
        internalType: 'struct SignedInvocation',
        type: 'tuple',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyInvocationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Template
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const templateABI = [{ stateMutability: 'nonpayable', type: 'constructor', inputs: [] }] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ERC20FromAllowanceEnforcer
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const erc20FromAllowanceEnforcerABI = [
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'terms', internalType: 'bytes', type: 'bytes' },
      {
        name: 'transaction',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
      { name: 'delegationHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'enforceCaveat',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TokenPermit
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const tokenPermitABI = [
  { stateMutability: 'nonpayable', type: 'constructor', inputs: [] },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address', indexed: true },
      { name: 'spender', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Approval',
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'from', internalType: 'address', type: 'address', indexed: true },
      { name: 'to', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Transfer',
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [],
    name: 'DOMAIN_SEPARATOR',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
    ],
    name: 'allowance',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'decimals', outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'subtractedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'decreaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'addedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'increaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'name', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'owner', internalType: 'address', type: 'address' }],
    name: 'nonces',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'value', internalType: 'uint256', type: 'uint256' },
      { name: 'deadline', internalType: 'uint256', type: 'uint256' },
      { name: 'v', internalType: 'uint8', type: 'uint8' },
      { name: 'r', internalType: 'bytes32', type: 'bytes32' },
      { name: 's', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'permit',
    outputs: [],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'symbol', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'totalSupply', outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'from', internalType: 'address', type: 'address' },
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferFrom',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CaveatEnforcer
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const caveatEnforcerABI = [
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'terms', internalType: 'bytes', type: 'bytes' },
      {
        name: 'tx',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
      { name: 'delegationHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'enforceCaveat',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DelegatableCore
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const delegatableCoreABI = [
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat[]',
        type: 'tuple[]',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat',
        type: 'tuple',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_DELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATIONS_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation',
        type: 'tuple',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct ReplayProtection',
        type: 'tuple',
        components: [
          { name: 'nonce', internalType: 'uint256', type: 'uint256' },
          { name: 'queue', internalType: 'uint256', type: 'uint256' },
        ],
      },
    ],
    name: 'GET_REPLAYPROTECTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_TRANSACTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'intendedSender', internalType: 'address', type: 'address' },
      { name: 'queue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'getNonce',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyDelegationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// EIP712Decoder
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const eip712DecoderABI = [
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat[]',
        type: 'tuple[]',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Caveat',
        type: 'tuple',
        components: [
          { name: 'enforcer', internalType: 'address', type: 'address' },
          { name: 'terms', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_CAVEAT_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_DELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATIONS_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Invocation',
        type: 'tuple',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'GET_INVOCATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct ReplayProtection',
        type: 'tuple',
        components: [
          { name: 'nonce', internalType: 'uint256', type: 'uint256' },
          { name: 'queue', internalType: 'uint256', type: 'uint256' },
        ],
      },
    ],
    name: 'GET_REPLAYPROTECTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_SIGNEDDELEGATION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      {
        name: '_input',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'GET_TRANSACTION_PACKETHASH',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Ownable
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const ownableABI = [
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'previousOwner', internalType: 'address', type: 'address', indexed: true },
      { name: 'newOwner', internalType: 'address', type: 'address', indexed: true },
    ],
    name: 'OwnershipTransferred',
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'owner', outputs: [{ name: '', internalType: 'address', type: 'address' }] },
  { stateMutability: 'nonpayable', type: 'function', inputs: [], name: 'renounceOwnership', outputs: [] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [{ name: 'newOwner', internalType: 'address', type: 'address' }],
    name: 'transferOwnership',
    outputs: [],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TimestampAfterEnforcer
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const timestampAfterEnforcerABI = [
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'terms', internalType: 'bytes', type: 'bytes' },
      {
        name: 'transaction',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
      { name: 'delegationHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'enforceCaveat',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TimestampBeforeEnforcer
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const timestampBeforeEnforcerABI = [
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'terms', internalType: 'bytes', type: 'bytes' },
      {
        name: 'transaction',
        internalType: 'struct Transaction',
        type: 'tuple',
        components: [
          { name: 'to', internalType: 'address', type: 'address' },
          { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
          { name: 'data', internalType: 'bytes', type: 'bytes' },
        ],
      },
      { name: 'delegationHash', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'enforceCaveat',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IDelegatable
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const iDelegatableABI = [
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'batch',
        internalType: 'struct Invocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'transaction',
            internalType: 'struct Transaction',
            type: 'tuple',
            components: [
              { name: 'to', internalType: 'address', type: 'address' },
              { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
              { name: 'data', internalType: 'bytes', type: 'bytes' },
            ],
          },
          {
            name: 'authority',
            internalType: 'struct SignedDelegation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'delegation',
                internalType: 'struct Delegation',
                type: 'tuple',
                components: [
                  { name: 'delegate', internalType: 'address', type: 'address' },
                  { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                  {
                    name: 'caveats',
                    internalType: 'struct Caveat[]',
                    type: 'tuple[]',
                    components: [
                      { name: 'enforcer', internalType: 'address', type: 'address' },
                      { name: 'terms', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              { name: 'signature', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'contractInvoke',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'delegation',
        internalType: 'struct Delegation',
        type: 'tuple',
        components: [
          { name: 'delegate', internalType: 'address', type: 'address' },
          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
          {
            name: 'caveats',
            internalType: 'struct Caveat[]',
            type: 'tuple[]',
            components: [
              { name: 'enforcer', internalType: 'address', type: 'address' },
              { name: 'terms', internalType: 'bytes', type: 'bytes' },
            ],
          },
        ],
      },
    ],
    name: 'getDelegationTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'pure',
    type: 'function',
    inputs: [
      { name: 'contractName', internalType: 'string', type: 'string' },
      { name: 'version', internalType: 'string', type: 'string' },
      { name: 'chainId', internalType: 'uint256', type: 'uint256' },
      { name: 'verifyingContract', internalType: 'address', type: 'address' },
    ],
    name: 'getEIP712DomainHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'invocations',
        internalType: 'struct Invocations',
        type: 'tuple',
        components: [
          {
            name: 'batch',
            internalType: 'struct Invocation[]',
            type: 'tuple[]',
            components: [
              {
                name: 'transaction',
                internalType: 'struct Transaction',
                type: 'tuple',
                components: [
                  { name: 'to', internalType: 'address', type: 'address' },
                  { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                  { name: 'data', internalType: 'bytes', type: 'bytes' },
                ],
              },
              {
                name: 'authority',
                internalType: 'struct SignedDelegation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'delegation',
                    internalType: 'struct Delegation',
                    type: 'tuple',
                    components: [
                      { name: 'delegate', internalType: 'address', type: 'address' },
                      { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                      {
                        name: 'caveats',
                        internalType: 'struct Caveat[]',
                        type: 'tuple[]',
                        components: [
                          { name: 'enforcer', internalType: 'address', type: 'address' },
                          { name: 'terms', internalType: 'bytes', type: 'bytes' },
                        ],
                      },
                    ],
                  },
                  { name: 'signature', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          {
            name: 'replayProtection',
            internalType: 'struct ReplayProtection',
            type: 'tuple',
            components: [
              { name: 'nonce', internalType: 'uint256', type: 'uint256' },
              { name: 'queue', internalType: 'uint256', type: 'uint256' },
            ],
          },
        ],
      },
    ],
    name: 'getInvocationsTypedDataHash',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocations',
        internalType: 'struct SignedInvocation[]',
        type: 'tuple[]',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'invoke',
    outputs: [{ name: 'success', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedDelegation',
        internalType: 'struct SignedDelegation',
        type: 'tuple',
        components: [
          {
            name: 'delegation',
            internalType: 'struct Delegation',
            type: 'tuple',
            components: [
              { name: 'delegate', internalType: 'address', type: 'address' },
              { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
              {
                name: 'caveats',
                internalType: 'struct Caveat[]',
                type: 'tuple[]',
                components: [
                  { name: 'enforcer', internalType: 'address', type: 'address' },
                  { name: 'terms', internalType: 'bytes', type: 'bytes' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyDelegationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      {
        name: 'signedInvocation',
        internalType: 'struct SignedInvocation',
        type: 'tuple',
        components: [
          {
            name: 'invocations',
            internalType: 'struct Invocations',
            type: 'tuple',
            components: [
              {
                name: 'batch',
                internalType: 'struct Invocation[]',
                type: 'tuple[]',
                components: [
                  {
                    name: 'transaction',
                    internalType: 'struct Transaction',
                    type: 'tuple',
                    components: [
                      { name: 'to', internalType: 'address', type: 'address' },
                      { name: 'gasLimit', internalType: 'uint256', type: 'uint256' },
                      { name: 'data', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                  {
                    name: 'authority',
                    internalType: 'struct SignedDelegation[]',
                    type: 'tuple[]',
                    components: [
                      {
                        name: 'delegation',
                        internalType: 'struct Delegation',
                        type: 'tuple',
                        components: [
                          { name: 'delegate', internalType: 'address', type: 'address' },
                          { name: 'authority', internalType: 'bytes32', type: 'bytes32' },
                          {
                            name: 'caveats',
                            internalType: 'struct Caveat[]',
                            type: 'tuple[]',
                            components: [
                              { name: 'enforcer', internalType: 'address', type: 'address' },
                              { name: 'terms', internalType: 'bytes', type: 'bytes' },
                            ],
                          },
                        ],
                      },
                      { name: 'signature', internalType: 'bytes', type: 'bytes' },
                    ],
                  },
                ],
              },
              {
                name: 'replayProtection',
                internalType: 'struct ReplayProtection',
                type: 'tuple',
                components: [
                  { name: 'nonce', internalType: 'uint256', type: 'uint256' },
                  { name: 'queue', internalType: 'uint256', type: 'uint256' },
                ],
              },
            ],
          },
          { name: 'signature', internalType: 'bytes', type: 'bytes' },
        ],
      },
    ],
    name: 'verifyInvocationSignature',
    outputs: [{ name: '', internalType: 'address', type: 'address' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ERC20
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const erc20ABI = [
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      { name: 'name_', internalType: 'string', type: 'string' },
      { name: 'symbol_', internalType: 'string', type: 'string' },
    ],
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address', indexed: true },
      { name: 'spender', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Approval',
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'from', internalType: 'address', type: 'address', indexed: true },
      { name: 'to', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Transfer',
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
    ],
    name: 'allowance',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'decimals', outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'subtractedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'decreaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'addedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'increaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'name', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'symbol', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'totalSupply', outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'from', internalType: 'address', type: 'address' },
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferFrom',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IERC20
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const ierc20ABI = [
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address', indexed: true },
      { name: 'spender', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Approval',
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'from', internalType: 'address', type: 'address', indexed: true },
      { name: 'to', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Transfer',
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
    ],
    name: 'allowance',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'totalSupply', outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'from', internalType: 'address', type: 'address' },
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferFrom',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IERC20Metadata
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const ierc20MetadataABI = [
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address', indexed: true },
      { name: 'spender', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Approval',
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'from', internalType: 'address', type: 'address', indexed: true },
      { name: 'to', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Transfer',
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
    ],
    name: 'allowance',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'decimals', outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'name', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'symbol', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'totalSupply', outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'from', internalType: 'address', type: 'address' },
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferFrom',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ERC20Permit
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const erc20PermitABI = [
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address', indexed: true },
      { name: 'spender', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Approval',
  },
  {
    type: 'event',
    anonymous: false,
    inputs: [
      { name: 'from', internalType: 'address', type: 'address', indexed: true },
      { name: 'to', internalType: 'address', type: 'address', indexed: true },
      { name: 'value', internalType: 'uint256', type: 'uint256', indexed: false },
    ],
    name: 'Transfer',
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [],
    name: 'DOMAIN_SEPARATOR',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
    ],
    name: 'allowance',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'approve',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'account', internalType: 'address', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'decimals', outputs: [{ name: '', internalType: 'uint8', type: 'uint8' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'subtractedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'decreaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'addedValue', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'increaseAllowance',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'name', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'owner', internalType: 'address', type: 'address' }],
    name: 'nonces',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'value', internalType: 'uint256', type: 'uint256' },
      { name: 'deadline', internalType: 'uint256', type: 'uint256' },
      { name: 'v', internalType: 'uint8', type: 'uint8' },
      { name: 'r', internalType: 'bytes32', type: 'bytes32' },
      { name: 's', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'permit',
    outputs: [],
  },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'symbol', outputs: [{ name: '', internalType: 'string', type: 'string' }] },
  { stateMutability: 'view', type: 'function', inputs: [], name: 'totalSupply', outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }] },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'from', internalType: 'address', type: 'address' },
      { name: 'to', internalType: 'address', type: 'address' },
      { name: 'amount', internalType: 'uint256', type: 'uint256' },
    ],
    name: 'transferFrom',
    outputs: [{ name: '', internalType: 'bool', type: 'bool' }],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IERC20Permit
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

export const ierc20PermitABI = [
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [],
    name: 'DOMAIN_SEPARATOR',
    outputs: [{ name: '', internalType: 'bytes32', type: 'bytes32' }],
  },
  {
    stateMutability: 'view',
    type: 'function',
    inputs: [{ name: 'owner', internalType: 'address', type: 'address' }],
    name: 'nonces',
    outputs: [{ name: '', internalType: 'uint256', type: 'uint256' }],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    inputs: [
      { name: 'owner', internalType: 'address', type: 'address' },
      { name: 'spender', internalType: 'address', type: 'address' },
      { name: 'value', internalType: 'uint256', type: 'uint256' },
      { name: 'deadline', internalType: 'uint256', type: 'uint256' },
      { name: 'v', internalType: 'uint8', type: 'uint8' },
      { name: 'r', internalType: 'bytes32', type: 'bytes32' },
      { name: 's', internalType: 'bytes32', type: 'bytes32' },
    ],
    name: 'permit',
    outputs: [],
  },
] as const

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// React
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link delegatableABI}__.
 */
export function useDelegatable(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: delegatableABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__.
 */
export function useDelegatableRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof delegatableABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, ...config } as UseContractReadConfig<typeof delegatableABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_CAVEAT_ARRAY_PACKETHASH"`.
 */
export function useDelegatableGetCaveatArrayPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_CAVEAT_ARRAY_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_CAVEAT_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_CAVEAT_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_CAVEAT_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_CAVEAT_PACKETHASH"`.
 */
export function useDelegatableGetCaveatPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_CAVEAT_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_CAVEAT_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_CAVEAT_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_CAVEAT_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_DELEGATION_PACKETHASH"`.
 */
export function useDelegatableGetDelegationPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_DELEGATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_DELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_DELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_DELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_INVOCATIONS_PACKETHASH"`.
 */
export function useDelegatableGetInvocationsPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_INVOCATIONS_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_INVOCATIONS_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_INVOCATIONS_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_INVOCATIONS_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_INVOCATION_ARRAY_PACKETHASH"`.
 */
export function useDelegatableGetInvocationArrayPackethash<
  TSelectData = ReadContractResult<typeof delegatableABI, 'GET_INVOCATION_ARRAY_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_INVOCATION_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_INVOCATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_INVOCATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_INVOCATION_PACKETHASH"`.
 */
export function useDelegatableGetInvocationPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_INVOCATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_INVOCATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_INVOCATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_INVOCATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_REPLAYPROTECTION_PACKETHASH"`.
 */
export function useDelegatableGetReplayprotectionPackethash<
  TSelectData = ReadContractResult<typeof delegatableABI, 'GET_REPLAYPROTECTION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_REPLAYPROTECTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_REPLAYPROTECTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_REPLAYPROTECTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_ARRAY_PACKETHASH"`.
 */
export function useDelegatableGetSigneddelegationArrayPackethash<
  TSelectData = ReadContractResult<typeof delegatableABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH'>
>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_PACKETHASH"`.
 */
export function useDelegatableGetSigneddelegationPackethash<
  TSelectData = ReadContractResult<typeof delegatableABI, 'GET_SIGNEDDELEGATION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_SIGNEDDELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_SIGNEDDELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_SIGNEDDELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"GET_TRANSACTION_PACKETHASH"`.
 */
export function useDelegatableGetTransactionPackethash<TSelectData = ReadContractResult<typeof delegatableABI, 'GET_TRANSACTION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'GET_TRANSACTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'GET_TRANSACTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'GET_TRANSACTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"domainHash"`.
 */
export function useDelegatableDomainHash<TSelectData = ReadContractResult<typeof delegatableABI, 'domainHash'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'domainHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'domainHash', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'domainHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"getDelegationTypedDataHash"`.
 */
export function useDelegatableGetDelegationTypedDataHash<TSelectData = ReadContractResult<typeof delegatableABI, 'getDelegationTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'getDelegationTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'getDelegationTypedDataHash', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'getDelegationTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"getEIP712DomainHash"`.
 */
export function useDelegatableGetEip712DomainHash<TSelectData = ReadContractResult<typeof delegatableABI, 'getEIP712DomainHash'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'getEIP712DomainHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'getEIP712DomainHash', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'getEIP712DomainHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"getInvocationsTypedDataHash"`.
 */
export function useDelegatableGetInvocationsTypedDataHash<TSelectData = ReadContractResult<typeof delegatableABI, 'getInvocationsTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'getInvocationsTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'getInvocationsTypedDataHash', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'getInvocationsTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"getNonce"`.
 */
export function useDelegatableGetNonce<TSelectData = ReadContractResult<typeof delegatableABI, 'getNonce'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'getNonce', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'getNonce', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'getNonce',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"verifyDelegationSignature"`.
 */
export function useDelegatableVerifyDelegationSignature<TSelectData = ReadContractResult<typeof delegatableABI, 'verifyDelegationSignature'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'verifyDelegationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'verifyDelegationSignature', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'verifyDelegationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"verifyInvocationSignature"`.
 */
export function useDelegatableVerifyInvocationSignature<TSelectData = ReadContractResult<typeof delegatableABI, 'verifyInvocationSignature'>>(
  config: Omit<UseContractReadConfig<typeof delegatableABI, 'verifyInvocationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableABI, functionName: 'verifyInvocationSignature', ...config } as UseContractReadConfig<
    typeof delegatableABI,
    'verifyInvocationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link delegatableABI}__.
 */
export function useDelegatableWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof delegatableABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof delegatableABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof delegatableABI, TFunctionName>({ abi: delegatableABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function useDelegatableContractInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof delegatableABI, 'contractInvoke'>['abi'], 'contractInvoke'> & {
        functionName?: 'contractInvoke'
      }
    : UseContractWriteConfig<TMode, typeof delegatableABI, 'contractInvoke'> & {
        abi?: never
        functionName?: 'contractInvoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof delegatableABI, 'contractInvoke'>({ abi: delegatableABI, functionName: 'contractInvoke', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"invoke"`.
 */
export function useDelegatableInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof delegatableABI, 'invoke'>['abi'], 'invoke'> & { functionName?: 'invoke' }
    : UseContractWriteConfig<TMode, typeof delegatableABI, 'invoke'> & {
        abi?: never
        functionName?: 'invoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof delegatableABI, 'invoke'>({ abi: delegatableABI, functionName: 'invoke', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link delegatableABI}__.
 */
export function usePrepareDelegatableWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof delegatableABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: delegatableABI, ...config } as UsePrepareContractWriteConfig<typeof delegatableABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function usePrepareDelegatableContractInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof delegatableABI, 'contractInvoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: delegatableABI, functionName: 'contractInvoke', ...config } as UsePrepareContractWriteConfig<
    typeof delegatableABI,
    'contractInvoke'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link delegatableABI}__ and `functionName` set to `"invoke"`.
 */
export function usePrepareDelegatableInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof delegatableABI, 'invoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: delegatableABI, functionName: 'invoke', ...config } as UsePrepareContractWriteConfig<
    typeof delegatableABI,
    'invoke'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link erc20ManagerABI}__.
 */
export function useErc20Manager(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: erc20ManagerABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__.
 */
export function useErc20ManagerRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof erc20ManagerABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, ...config } as UseContractReadConfig<typeof erc20ManagerABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_CAVEAT_ARRAY_PACKETHASH"`.
 */
export function useErc20ManagerGetCaveatArrayPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_CAVEAT_ARRAY_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_CAVEAT_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_CAVEAT_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_CAVEAT_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_CAVEAT_PACKETHASH"`.
 */
export function useErc20ManagerGetCaveatPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_CAVEAT_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_CAVEAT_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_CAVEAT_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_CAVEAT_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_DELEGATION_PACKETHASH"`.
 */
export function useErc20ManagerGetDelegationPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_DELEGATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_DELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_DELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_DELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_INVOCATIONS_PACKETHASH"`.
 */
export function useErc20ManagerGetInvocationsPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_INVOCATIONS_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_INVOCATIONS_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_INVOCATIONS_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_INVOCATIONS_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_INVOCATION_ARRAY_PACKETHASH"`.
 */
export function useErc20ManagerGetInvocationArrayPackethash<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_INVOCATION_ARRAY_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_INVOCATION_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_INVOCATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_INVOCATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_INVOCATION_PACKETHASH"`.
 */
export function useErc20ManagerGetInvocationPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_INVOCATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_INVOCATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_INVOCATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_INVOCATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_REPLAYPROTECTION_PACKETHASH"`.
 */
export function useErc20ManagerGetReplayprotectionPackethash<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_REPLAYPROTECTION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_REPLAYPROTECTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_REPLAYPROTECTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_REPLAYPROTECTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_ARRAY_PACKETHASH"`.
 */
export function useErc20ManagerGetSigneddelegationArrayPackethash<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH'>
>(
  config: Omit<
    UseContractReadConfig<typeof erc20ManagerABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', TSelectData>,
    'abi' | 'functionName'
  > = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_PACKETHASH"`.
 */
export function useErc20ManagerGetSigneddelegationPackethash<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_SIGNEDDELEGATION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_SIGNEDDELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_SIGNEDDELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_SIGNEDDELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"GET_TRANSACTION_PACKETHASH"`.
 */
export function useErc20ManagerGetTransactionPackethash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'GET_TRANSACTION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'GET_TRANSACTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'GET_TRANSACTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'GET_TRANSACTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"domainHash"`.
 */
export function useErc20ManagerDomainHash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'domainHash'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'domainHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'domainHash', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'domainHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"getDelegationTypedDataHash"`.
 */
export function useErc20ManagerGetDelegationTypedDataHash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'getDelegationTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'getDelegationTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'getDelegationTypedDataHash', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'getDelegationTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"getEIP712DomainHash"`.
 */
export function useErc20ManagerGetEip712DomainHash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'getEIP712DomainHash'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'getEIP712DomainHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'getEIP712DomainHash', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'getEIP712DomainHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"getExternalDelegationTypedDataHash"`.
 */
export function useErc20ManagerGetExternalDelegationTypedDataHash<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'getExternalDelegationTypedDataHash'>
>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'getExternalDelegationTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'getExternalDelegationTypedDataHash', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'getExternalDelegationTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"getInvocationsTypedDataHash"`.
 */
export function useErc20ManagerGetInvocationsTypedDataHash<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'getInvocationsTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'getInvocationsTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'getInvocationsTypedDataHash', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'getInvocationsTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"getNonce"`.
 */
export function useErc20ManagerGetNonce<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'getNonce'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'getNonce', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'getNonce', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'getNonce',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"isRevoked"`.
 */
export function useErc20ManagerIsRevoked<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'isRevoked'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'isRevoked', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'isRevoked', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'isRevoked',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"owner"`.
 */
export function useErc20ManagerOwner<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'owner'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'owner', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'owner', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'owner',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"verifyDelegationSignature"`.
 */
export function useErc20ManagerVerifyDelegationSignature<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'verifyDelegationSignature'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'verifyDelegationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'verifyDelegationSignature', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'verifyDelegationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"verifyExternalDelegationSignature"`.
 */
export function useErc20ManagerVerifyExternalDelegationSignature<
  TSelectData = ReadContractResult<typeof erc20ManagerABI, 'verifyExternalDelegationSignature'>
>(config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'verifyExternalDelegationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'verifyExternalDelegationSignature', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'verifyExternalDelegationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"verifyInvocationSignature"`.
 */
export function useErc20ManagerVerifyInvocationSignature<TSelectData = ReadContractResult<typeof erc20ManagerABI, 'verifyInvocationSignature'>>(
  config: Omit<UseContractReadConfig<typeof erc20ManagerABI, 'verifyInvocationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ManagerABI, functionName: 'verifyInvocationSignature', ...config } as UseContractReadConfig<
    typeof erc20ManagerABI,
    'verifyInvocationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__.
 */
export function useErc20ManagerWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, TFunctionName>({ abi: erc20ManagerABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"approveTransferProxy"`.
 */
export function useErc20ManagerApproveTransferProxy<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'approveTransferProxy'>['abi'], 'approveTransferProxy'> & {
        functionName?: 'approveTransferProxy'
      }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'approveTransferProxy'> & {
        abi?: never
        functionName?: 'approveTransferProxy'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'approveTransferProxy'>({
    abi: erc20ManagerABI,
    functionName: 'approveTransferProxy',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function useErc20ManagerContractInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'contractInvoke'>['abi'], 'contractInvoke'> & {
        functionName?: 'contractInvoke'
      }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'contractInvoke'> & {
        abi?: never
        functionName?: 'contractInvoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'contractInvoke'>({ abi: erc20ManagerABI, functionName: 'contractInvoke', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"invoke"`.
 */
export function useErc20ManagerInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'invoke'>['abi'], 'invoke'> & { functionName?: 'invoke' }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'invoke'> & {
        abi?: never
        functionName?: 'invoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'invoke'>({ abi: erc20ManagerABI, functionName: 'invoke', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function useErc20ManagerRenounceOwnership<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'renounceOwnership'>['abi'], 'renounceOwnership'> & {
        functionName?: 'renounceOwnership'
      }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'renounceOwnership'> & {
        abi?: never
        functionName?: 'renounceOwnership'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'renounceOwnership'>({
    abi: erc20ManagerABI,
    functionName: 'renounceOwnership',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"revoke"`.
 */
export function useErc20ManagerRevoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'revoke'>['abi'], 'revoke'> & { functionName?: 'revoke' }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'revoke'> & {
        abi?: never
        functionName?: 'revoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'revoke'>({ abi: erc20ManagerABI, functionName: 'revoke', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function useErc20ManagerTransferOwnership<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'transferOwnership'>['abi'], 'transferOwnership'> & {
        functionName?: 'transferOwnership'
      }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'transferOwnership'> & {
        abi?: never
        functionName?: 'transferOwnership'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'transferOwnership'>({
    abi: erc20ManagerABI,
    functionName: 'transferOwnership',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"transferProxy"`.
 */
export function useErc20ManagerTransferProxy<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ManagerABI, 'transferProxy'>['abi'], 'transferProxy'> & {
        functionName?: 'transferProxy'
      }
    : UseContractWriteConfig<TMode, typeof erc20ManagerABI, 'transferProxy'> & {
        abi?: never
        functionName?: 'transferProxy'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ManagerABI, 'transferProxy'>({ abi: erc20ManagerABI, functionName: 'transferProxy', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__.
 */
export function usePrepareErc20ManagerWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, ...config } as UsePrepareContractWriteConfig<typeof erc20ManagerABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"approveTransferProxy"`.
 */
export function usePrepareErc20ManagerApproveTransferProxy(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'approveTransferProxy'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'approveTransferProxy', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'approveTransferProxy'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function usePrepareErc20ManagerContractInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'contractInvoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'contractInvoke', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'contractInvoke'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"invoke"`.
 */
export function usePrepareErc20ManagerInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'invoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'invoke', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'invoke'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function usePrepareErc20ManagerRenounceOwnership(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'renounceOwnership'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'renounceOwnership', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'renounceOwnership'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"revoke"`.
 */
export function usePrepareErc20ManagerRevoke(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'revoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'revoke', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'revoke'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function usePrepareErc20ManagerTransferOwnership(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'transferOwnership'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'transferOwnership', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'transferOwnership'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ManagerABI}__ and `functionName` set to `"transferProxy"`.
 */
export function usePrepareErc20ManagerTransferProxy(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ManagerABI, 'transferProxy'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ManagerABI, functionName: 'transferProxy', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ManagerABI,
    'transferProxy'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20ManagerABI}__.
 */
export function useErc20ManagerEvent<TEventName extends string>(
  config: Omit<UseContractEventConfig<typeof erc20ManagerABI, TEventName>, 'abi'> = {} as any
) {
  return useContractEvent({ abi: erc20ManagerABI, ...config } as UseContractEventConfig<typeof erc20ManagerABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20ManagerABI}__ and `eventName` set to `"OwnershipTransferred"`.
 */
export function useErc20ManagerOwnershipTransferredEvent(
  config: Omit<UseContractEventConfig<typeof erc20ManagerABI, 'OwnershipTransferred'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: erc20ManagerABI, eventName: 'OwnershipTransferred', ...config } as UseContractEventConfig<
    typeof erc20ManagerABI,
    'OwnershipTransferred'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link templateABI}__.
 */
export function useTemplate(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: templateABI, ...config })
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link erc20FromAllowanceEnforcerABI}__.
 */
export function useErc20FromAllowanceEnforcer(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: erc20FromAllowanceEnforcerABI, ...config })
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20FromAllowanceEnforcerABI}__.
 */
export function useErc20FromAllowanceEnforcerWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20FromAllowanceEnforcerABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof erc20FromAllowanceEnforcerABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20FromAllowanceEnforcerABI, TFunctionName>({ abi: erc20FromAllowanceEnforcerABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20FromAllowanceEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function useErc20FromAllowanceEnforcerEnforceCaveat<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20FromAllowanceEnforcerABI, 'enforceCaveat'>['abi'], 'enforceCaveat'> & {
        functionName?: 'enforceCaveat'
      }
    : UseContractWriteConfig<TMode, typeof erc20FromAllowanceEnforcerABI, 'enforceCaveat'> & {
        abi?: never
        functionName?: 'enforceCaveat'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20FromAllowanceEnforcerABI, 'enforceCaveat'>({
    abi: erc20FromAllowanceEnforcerABI,
    functionName: 'enforceCaveat',
    ...config,
  } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20FromAllowanceEnforcerABI}__.
 */
export function usePrepareErc20FromAllowanceEnforcerWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20FromAllowanceEnforcerABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20FromAllowanceEnforcerABI, ...config } as UsePrepareContractWriteConfig<
    typeof erc20FromAllowanceEnforcerABI,
    TFunctionName
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20FromAllowanceEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function usePrepareErc20FromAllowanceEnforcerEnforceCaveat(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20FromAllowanceEnforcerABI, 'enforceCaveat'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20FromAllowanceEnforcerABI, functionName: 'enforceCaveat', ...config } as UsePrepareContractWriteConfig<
    typeof erc20FromAllowanceEnforcerABI,
    'enforceCaveat'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link tokenPermitABI}__.
 */
export function useTokenPermit(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: tokenPermitABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__.
 */
export function useTokenPermitRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof tokenPermitABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, ...config } as UseContractReadConfig<typeof tokenPermitABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"DOMAIN_SEPARATOR"`.
 */
export function useTokenPermitDomainSeparator<TSelectData = ReadContractResult<typeof tokenPermitABI, 'DOMAIN_SEPARATOR'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'DOMAIN_SEPARATOR', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'DOMAIN_SEPARATOR', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'DOMAIN_SEPARATOR',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"allowance"`.
 */
export function useTokenPermitAllowance<TSelectData = ReadContractResult<typeof tokenPermitABI, 'allowance'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'allowance', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'allowance', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'allowance',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useTokenPermitBalanceOf<TSelectData = ReadContractResult<typeof tokenPermitABI, 'balanceOf'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'balanceOf', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'balanceOf', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'balanceOf',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"decimals"`.
 */
export function useTokenPermitDecimals<TSelectData = ReadContractResult<typeof tokenPermitABI, 'decimals'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'decimals', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'decimals', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'decimals',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"name"`.
 */
export function useTokenPermitName<TSelectData = ReadContractResult<typeof tokenPermitABI, 'name'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'name', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'name', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'name',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"nonces"`.
 */
export function useTokenPermitNonces<TSelectData = ReadContractResult<typeof tokenPermitABI, 'nonces'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'nonces', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'nonces', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'nonces',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"symbol"`.
 */
export function useTokenPermitSymbol<TSelectData = ReadContractResult<typeof tokenPermitABI, 'symbol'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'symbol', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'symbol', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'symbol',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useTokenPermitTotalSupply<TSelectData = ReadContractResult<typeof tokenPermitABI, 'totalSupply'>>(
  config: Omit<UseContractReadConfig<typeof tokenPermitABI, 'totalSupply', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: tokenPermitABI, functionName: 'totalSupply', ...config } as UseContractReadConfig<
    typeof tokenPermitABI,
    'totalSupply',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__.
 */
export function useTokenPermitWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, TFunctionName>({ abi: tokenPermitABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"approve"`.
 */
export function useTokenPermitApprove<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'approve'>['abi'], 'approve'> & { functionName?: 'approve' }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'approve'> & {
        abi?: never
        functionName?: 'approve'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'approve'>({ abi: tokenPermitABI, functionName: 'approve', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function useTokenPermitDecreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'decreaseAllowance'>['abi'], 'decreaseAllowance'> & {
        functionName?: 'decreaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'decreaseAllowance'> & {
        abi?: never
        functionName?: 'decreaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'decreaseAllowance'>({
    abi: tokenPermitABI,
    functionName: 'decreaseAllowance',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function useTokenPermitIncreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'increaseAllowance'>['abi'], 'increaseAllowance'> & {
        functionName?: 'increaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'increaseAllowance'> & {
        abi?: never
        functionName?: 'increaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'increaseAllowance'>({
    abi: tokenPermitABI,
    functionName: 'increaseAllowance',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"permit"`.
 */
export function useTokenPermitPermit<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'permit'>['abi'], 'permit'> & { functionName?: 'permit' }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'permit'> & {
        abi?: never
        functionName?: 'permit'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'permit'>({ abi: tokenPermitABI, functionName: 'permit', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"transfer"`.
 */
export function useTokenPermitTransfer<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'transfer'>['abi'], 'transfer'> & { functionName?: 'transfer' }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'transfer'> & {
        abi?: never
        functionName?: 'transfer'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'transfer'>({ abi: tokenPermitABI, functionName: 'transfer', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useTokenPermitTransferFrom<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof tokenPermitABI, 'transferFrom'>['abi'], 'transferFrom'> & {
        functionName?: 'transferFrom'
      }
    : UseContractWriteConfig<TMode, typeof tokenPermitABI, 'transferFrom'> & {
        abi?: never
        functionName?: 'transferFrom'
      } = {} as any
) {
  return useContractWrite<TMode, typeof tokenPermitABI, 'transferFrom'>({ abi: tokenPermitABI, functionName: 'transferFrom', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__.
 */
export function usePrepareTokenPermitWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, ...config } as UsePrepareContractWriteConfig<typeof tokenPermitABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareTokenPermitApprove(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'approve'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'approve', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'approve'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function usePrepareTokenPermitDecreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'decreaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'decreaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'decreaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function usePrepareTokenPermitIncreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'increaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'increaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'increaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"permit"`.
 */
export function usePrepareTokenPermitPermit(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'permit'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'permit', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'permit'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareTokenPermitTransfer(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'transfer'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'transfer', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'transfer'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link tokenPermitABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareTokenPermitTransferFrom(
  config: Omit<UsePrepareContractWriteConfig<typeof tokenPermitABI, 'transferFrom'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: tokenPermitABI, functionName: 'transferFrom', ...config } as UsePrepareContractWriteConfig<
    typeof tokenPermitABI,
    'transferFrom'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link tokenPermitABI}__.
 */
export function useTokenPermitEvent<TEventName extends string>(
  config: Omit<UseContractEventConfig<typeof tokenPermitABI, TEventName>, 'abi'> = {} as any
) {
  return useContractEvent({ abi: tokenPermitABI, ...config } as UseContractEventConfig<typeof tokenPermitABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link tokenPermitABI}__ and `eventName` set to `"Approval"`.
 */
export function useTokenPermitApprovalEvent(
  config: Omit<UseContractEventConfig<typeof tokenPermitABI, 'Approval'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: tokenPermitABI, eventName: 'Approval', ...config } as UseContractEventConfig<typeof tokenPermitABI, 'Approval'>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link tokenPermitABI}__ and `eventName` set to `"Transfer"`.
 */
export function useTokenPermitTransferEvent(
  config: Omit<UseContractEventConfig<typeof tokenPermitABI, 'Transfer'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: tokenPermitABI, eventName: 'Transfer', ...config } as UseContractEventConfig<typeof tokenPermitABI, 'Transfer'>)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link caveatEnforcerABI}__.
 */
export function useCaveatEnforcer(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: caveatEnforcerABI, ...config })
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link caveatEnforcerABI}__.
 */
export function useCaveatEnforcerWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof caveatEnforcerABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof caveatEnforcerABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof caveatEnforcerABI, TFunctionName>({ abi: caveatEnforcerABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link caveatEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function useCaveatEnforcerEnforceCaveat<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof caveatEnforcerABI, 'enforceCaveat'>['abi'], 'enforceCaveat'> & {
        functionName?: 'enforceCaveat'
      }
    : UseContractWriteConfig<TMode, typeof caveatEnforcerABI, 'enforceCaveat'> & {
        abi?: never
        functionName?: 'enforceCaveat'
      } = {} as any
) {
  return useContractWrite<TMode, typeof caveatEnforcerABI, 'enforceCaveat'>({
    abi: caveatEnforcerABI,
    functionName: 'enforceCaveat',
    ...config,
  } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link caveatEnforcerABI}__.
 */
export function usePrepareCaveatEnforcerWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof caveatEnforcerABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: caveatEnforcerABI, ...config } as UsePrepareContractWriteConfig<typeof caveatEnforcerABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link caveatEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function usePrepareCaveatEnforcerEnforceCaveat(
  config: Omit<UsePrepareContractWriteConfig<typeof caveatEnforcerABI, 'enforceCaveat'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: caveatEnforcerABI, functionName: 'enforceCaveat', ...config } as UsePrepareContractWriteConfig<
    typeof caveatEnforcerABI,
    'enforceCaveat'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link delegatableCoreABI}__.
 */
export function useDelegatableCore(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: delegatableCoreABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__.
 */
export function useDelegatableCoreRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof delegatableCoreABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, ...config } as UseContractReadConfig<typeof delegatableCoreABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_CAVEAT_ARRAY_PACKETHASH"`.
 */
export function useDelegatableCoreGetCaveatArrayPackethash<
  TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_CAVEAT_ARRAY_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_CAVEAT_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_CAVEAT_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_CAVEAT_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_CAVEAT_PACKETHASH"`.
 */
export function useDelegatableCoreGetCaveatPackethash<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_CAVEAT_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_CAVEAT_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_CAVEAT_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_CAVEAT_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_DELEGATION_PACKETHASH"`.
 */
export function useDelegatableCoreGetDelegationPackethash<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_DELEGATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_DELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_DELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_DELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_INVOCATIONS_PACKETHASH"`.
 */
export function useDelegatableCoreGetInvocationsPackethash<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_INVOCATIONS_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_INVOCATIONS_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_INVOCATIONS_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_INVOCATIONS_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_INVOCATION_ARRAY_PACKETHASH"`.
 */
export function useDelegatableCoreGetInvocationArrayPackethash<
  TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_INVOCATION_ARRAY_PACKETHASH'>
>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_INVOCATION_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_INVOCATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_INVOCATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_INVOCATION_PACKETHASH"`.
 */
export function useDelegatableCoreGetInvocationPackethash<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_INVOCATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_INVOCATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_INVOCATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_INVOCATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_REPLAYPROTECTION_PACKETHASH"`.
 */
export function useDelegatableCoreGetReplayprotectionPackethash<
  TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_REPLAYPROTECTION_PACKETHASH'>
>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_REPLAYPROTECTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_REPLAYPROTECTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_REPLAYPROTECTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_ARRAY_PACKETHASH"`.
 */
export function useDelegatableCoreGetSigneddelegationArrayPackethash<
  TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH'>
>(
  config: Omit<
    UseContractReadConfig<typeof delegatableCoreABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', TSelectData>,
    'abi' | 'functionName'
  > = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_PACKETHASH"`.
 */
export function useDelegatableCoreGetSigneddelegationPackethash<
  TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_SIGNEDDELEGATION_PACKETHASH'>
>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_SIGNEDDELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_SIGNEDDELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_SIGNEDDELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"GET_TRANSACTION_PACKETHASH"`.
 */
export function useDelegatableCoreGetTransactionPackethash<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'GET_TRANSACTION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'GET_TRANSACTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'GET_TRANSACTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'GET_TRANSACTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"getNonce"`.
 */
export function useDelegatableCoreGetNonce<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'getNonce'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'getNonce', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'getNonce', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'getNonce',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link delegatableCoreABI}__ and `functionName` set to `"verifyDelegationSignature"`.
 */
export function useDelegatableCoreVerifyDelegationSignature<TSelectData = ReadContractResult<typeof delegatableCoreABI, 'verifyDelegationSignature'>>(
  config: Omit<UseContractReadConfig<typeof delegatableCoreABI, 'verifyDelegationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: delegatableCoreABI, functionName: 'verifyDelegationSignature', ...config } as UseContractReadConfig<
    typeof delegatableCoreABI,
    'verifyDelegationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link eip712DecoderABI}__.
 */
export function useEip712Decoder(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: eip712DecoderABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__.
 */
export function useEip712DecoderRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof eip712DecoderABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, ...config } as UseContractReadConfig<typeof eip712DecoderABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_CAVEAT_ARRAY_PACKETHASH"`.
 */
export function useEip712DecoderGetCaveatArrayPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_CAVEAT_ARRAY_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_CAVEAT_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_CAVEAT_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_CAVEAT_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_CAVEAT_PACKETHASH"`.
 */
export function useEip712DecoderGetCaveatPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_CAVEAT_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_CAVEAT_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_CAVEAT_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_CAVEAT_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_DELEGATION_PACKETHASH"`.
 */
export function useEip712DecoderGetDelegationPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_DELEGATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_DELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_DELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_DELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_INVOCATIONS_PACKETHASH"`.
 */
export function useEip712DecoderGetInvocationsPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_INVOCATIONS_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_INVOCATIONS_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_INVOCATIONS_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_INVOCATIONS_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_INVOCATION_ARRAY_PACKETHASH"`.
 */
export function useEip712DecoderGetInvocationArrayPackethash<
  TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_INVOCATION_ARRAY_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_INVOCATION_ARRAY_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_INVOCATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_INVOCATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_INVOCATION_PACKETHASH"`.
 */
export function useEip712DecoderGetInvocationPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_INVOCATION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_INVOCATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_INVOCATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_INVOCATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_REPLAYPROTECTION_PACKETHASH"`.
 */
export function useEip712DecoderGetReplayprotectionPackethash<
  TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_REPLAYPROTECTION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_REPLAYPROTECTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_REPLAYPROTECTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_REPLAYPROTECTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_ARRAY_PACKETHASH"`.
 */
export function useEip712DecoderGetSigneddelegationArrayPackethash<
  TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH'>
>(
  config: Omit<
    UseContractReadConfig<typeof eip712DecoderABI, 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', TSelectData>,
    'abi' | 'functionName'
  > = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_SIGNEDDELEGATION_ARRAY_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_SIGNEDDELEGATION_PACKETHASH"`.
 */
export function useEip712DecoderGetSigneddelegationPackethash<
  TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_SIGNEDDELEGATION_PACKETHASH'>
>(config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_SIGNEDDELEGATION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_SIGNEDDELEGATION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_SIGNEDDELEGATION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link eip712DecoderABI}__ and `functionName` set to `"GET_TRANSACTION_PACKETHASH"`.
 */
export function useEip712DecoderGetTransactionPackethash<TSelectData = ReadContractResult<typeof eip712DecoderABI, 'GET_TRANSACTION_PACKETHASH'>>(
  config: Omit<UseContractReadConfig<typeof eip712DecoderABI, 'GET_TRANSACTION_PACKETHASH', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: eip712DecoderABI, functionName: 'GET_TRANSACTION_PACKETHASH', ...config } as UseContractReadConfig<
    typeof eip712DecoderABI,
    'GET_TRANSACTION_PACKETHASH',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link ownableABI}__.
 */
export function useOwnable(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: ownableABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ownableABI}__.
 */
export function useOwnableRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof ownableABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof ownableABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: ownableABI, ...config } as UseContractReadConfig<typeof ownableABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ownableABI}__ and `functionName` set to `"owner"`.
 */
export function useOwnableOwner<TSelectData = ReadContractResult<typeof ownableABI, 'owner'>>(
  config: Omit<UseContractReadConfig<typeof ownableABI, 'owner', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ownableABI, functionName: 'owner', ...config } as UseContractReadConfig<typeof ownableABI, 'owner', TSelectData>)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ownableABI}__.
 */
export function useOwnableWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ownableABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof ownableABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof ownableABI, TFunctionName>({ abi: ownableABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ownableABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function useOwnableRenounceOwnership<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ownableABI, 'renounceOwnership'>['abi'], 'renounceOwnership'> & {
        functionName?: 'renounceOwnership'
      }
    : UseContractWriteConfig<TMode, typeof ownableABI, 'renounceOwnership'> & {
        abi?: never
        functionName?: 'renounceOwnership'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ownableABI, 'renounceOwnership'>({ abi: ownableABI, functionName: 'renounceOwnership', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ownableABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function useOwnableTransferOwnership<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ownableABI, 'transferOwnership'>['abi'], 'transferOwnership'> & {
        functionName?: 'transferOwnership'
      }
    : UseContractWriteConfig<TMode, typeof ownableABI, 'transferOwnership'> & {
        abi?: never
        functionName?: 'transferOwnership'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ownableABI, 'transferOwnership'>({ abi: ownableABI, functionName: 'transferOwnership', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ownableABI}__.
 */
export function usePrepareOwnableWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof ownableABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: ownableABI, ...config } as UsePrepareContractWriteConfig<typeof ownableABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ownableABI}__ and `functionName` set to `"renounceOwnership"`.
 */
export function usePrepareOwnableRenounceOwnership(
  config: Omit<UsePrepareContractWriteConfig<typeof ownableABI, 'renounceOwnership'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ownableABI, functionName: 'renounceOwnership', ...config } as UsePrepareContractWriteConfig<
    typeof ownableABI,
    'renounceOwnership'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ownableABI}__ and `functionName` set to `"transferOwnership"`.
 */
export function usePrepareOwnableTransferOwnership(
  config: Omit<UsePrepareContractWriteConfig<typeof ownableABI, 'transferOwnership'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ownableABI, functionName: 'transferOwnership', ...config } as UsePrepareContractWriteConfig<
    typeof ownableABI,
    'transferOwnership'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ownableABI}__.
 */
export function useOwnableEvent<TEventName extends string>(config: Omit<UseContractEventConfig<typeof ownableABI, TEventName>, 'abi'> = {} as any) {
  return useContractEvent({ abi: ownableABI, ...config } as UseContractEventConfig<typeof ownableABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ownableABI}__ and `eventName` set to `"OwnershipTransferred"`.
 */
export function useOwnableOwnershipTransferredEvent(
  config: Omit<UseContractEventConfig<typeof ownableABI, 'OwnershipTransferred'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: ownableABI, eventName: 'OwnershipTransferred', ...config } as UseContractEventConfig<
    typeof ownableABI,
    'OwnershipTransferred'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link timestampAfterEnforcerABI}__.
 */
export function useTimestampAfterEnforcer(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: timestampAfterEnforcerABI, ...config })
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link timestampAfterEnforcerABI}__.
 */
export function useTimestampAfterEnforcerWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof timestampAfterEnforcerABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof timestampAfterEnforcerABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof timestampAfterEnforcerABI, TFunctionName>({ abi: timestampAfterEnforcerABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link timestampAfterEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function useTimestampAfterEnforcerEnforceCaveat<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof timestampAfterEnforcerABI, 'enforceCaveat'>['abi'], 'enforceCaveat'> & {
        functionName?: 'enforceCaveat'
      }
    : UseContractWriteConfig<TMode, typeof timestampAfterEnforcerABI, 'enforceCaveat'> & {
        abi?: never
        functionName?: 'enforceCaveat'
      } = {} as any
) {
  return useContractWrite<TMode, typeof timestampAfterEnforcerABI, 'enforceCaveat'>({
    abi: timestampAfterEnforcerABI,
    functionName: 'enforceCaveat',
    ...config,
  } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link timestampAfterEnforcerABI}__.
 */
export function usePrepareTimestampAfterEnforcerWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof timestampAfterEnforcerABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: timestampAfterEnforcerABI, ...config } as UsePrepareContractWriteConfig<
    typeof timestampAfterEnforcerABI,
    TFunctionName
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link timestampAfterEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function usePrepareTimestampAfterEnforcerEnforceCaveat(
  config: Omit<UsePrepareContractWriteConfig<typeof timestampAfterEnforcerABI, 'enforceCaveat'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: timestampAfterEnforcerABI, functionName: 'enforceCaveat', ...config } as UsePrepareContractWriteConfig<
    typeof timestampAfterEnforcerABI,
    'enforceCaveat'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link timestampBeforeEnforcerABI}__.
 */
export function useTimestampBeforeEnforcer(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: timestampBeforeEnforcerABI, ...config })
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link timestampBeforeEnforcerABI}__.
 */
export function useTimestampBeforeEnforcerWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof timestampBeforeEnforcerABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof timestampBeforeEnforcerABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof timestampBeforeEnforcerABI, TFunctionName>({ abi: timestampBeforeEnforcerABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link timestampBeforeEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function useTimestampBeforeEnforcerEnforceCaveat<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof timestampBeforeEnforcerABI, 'enforceCaveat'>['abi'], 'enforceCaveat'> & {
        functionName?: 'enforceCaveat'
      }
    : UseContractWriteConfig<TMode, typeof timestampBeforeEnforcerABI, 'enforceCaveat'> & {
        abi?: never
        functionName?: 'enforceCaveat'
      } = {} as any
) {
  return useContractWrite<TMode, typeof timestampBeforeEnforcerABI, 'enforceCaveat'>({
    abi: timestampBeforeEnforcerABI,
    functionName: 'enforceCaveat',
    ...config,
  } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link timestampBeforeEnforcerABI}__.
 */
export function usePrepareTimestampBeforeEnforcerWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof timestampBeforeEnforcerABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: timestampBeforeEnforcerABI, ...config } as UsePrepareContractWriteConfig<
    typeof timestampBeforeEnforcerABI,
    TFunctionName
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link timestampBeforeEnforcerABI}__ and `functionName` set to `"enforceCaveat"`.
 */
export function usePrepareTimestampBeforeEnforcerEnforceCaveat(
  config: Omit<UsePrepareContractWriteConfig<typeof timestampBeforeEnforcerABI, 'enforceCaveat'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: timestampBeforeEnforcerABI, functionName: 'enforceCaveat', ...config } as UsePrepareContractWriteConfig<
    typeof timestampBeforeEnforcerABI,
    'enforceCaveat'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link iDelegatableABI}__.
 */
export function useIDelegatable(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: iDelegatableABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__.
 */
export function useIDelegatableRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof iDelegatableABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, ...config } as UseContractReadConfig<typeof iDelegatableABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"getDelegationTypedDataHash"`.
 */
export function useIDelegatableGetDelegationTypedDataHash<TSelectData = ReadContractResult<typeof iDelegatableABI, 'getDelegationTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, 'getDelegationTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, functionName: 'getDelegationTypedDataHash', ...config } as UseContractReadConfig<
    typeof iDelegatableABI,
    'getDelegationTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"getEIP712DomainHash"`.
 */
export function useIDelegatableGetEip712DomainHash<TSelectData = ReadContractResult<typeof iDelegatableABI, 'getEIP712DomainHash'>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, 'getEIP712DomainHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, functionName: 'getEIP712DomainHash', ...config } as UseContractReadConfig<
    typeof iDelegatableABI,
    'getEIP712DomainHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"getInvocationsTypedDataHash"`.
 */
export function useIDelegatableGetInvocationsTypedDataHash<TSelectData = ReadContractResult<typeof iDelegatableABI, 'getInvocationsTypedDataHash'>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, 'getInvocationsTypedDataHash', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, functionName: 'getInvocationsTypedDataHash', ...config } as UseContractReadConfig<
    typeof iDelegatableABI,
    'getInvocationsTypedDataHash',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"verifyDelegationSignature"`.
 */
export function useIDelegatableVerifyDelegationSignature<TSelectData = ReadContractResult<typeof iDelegatableABI, 'verifyDelegationSignature'>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, 'verifyDelegationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, functionName: 'verifyDelegationSignature', ...config } as UseContractReadConfig<
    typeof iDelegatableABI,
    'verifyDelegationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"verifyInvocationSignature"`.
 */
export function useIDelegatableVerifyInvocationSignature<TSelectData = ReadContractResult<typeof iDelegatableABI, 'verifyInvocationSignature'>>(
  config: Omit<UseContractReadConfig<typeof iDelegatableABI, 'verifyInvocationSignature', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: iDelegatableABI, functionName: 'verifyInvocationSignature', ...config } as UseContractReadConfig<
    typeof iDelegatableABI,
    'verifyInvocationSignature',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link iDelegatableABI}__.
 */
export function useIDelegatableWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof iDelegatableABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof iDelegatableABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof iDelegatableABI, TFunctionName>({ abi: iDelegatableABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function useIDelegatableContractInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof iDelegatableABI, 'contractInvoke'>['abi'], 'contractInvoke'> & {
        functionName?: 'contractInvoke'
      }
    : UseContractWriteConfig<TMode, typeof iDelegatableABI, 'contractInvoke'> & {
        abi?: never
        functionName?: 'contractInvoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof iDelegatableABI, 'contractInvoke'>({ abi: iDelegatableABI, functionName: 'contractInvoke', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"invoke"`.
 */
export function useIDelegatableInvoke<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof iDelegatableABI, 'invoke'>['abi'], 'invoke'> & { functionName?: 'invoke' }
    : UseContractWriteConfig<TMode, typeof iDelegatableABI, 'invoke'> & {
        abi?: never
        functionName?: 'invoke'
      } = {} as any
) {
  return useContractWrite<TMode, typeof iDelegatableABI, 'invoke'>({ abi: iDelegatableABI, functionName: 'invoke', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link iDelegatableABI}__.
 */
export function usePrepareIDelegatableWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof iDelegatableABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: iDelegatableABI, ...config } as UsePrepareContractWriteConfig<typeof iDelegatableABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"contractInvoke"`.
 */
export function usePrepareIDelegatableContractInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof iDelegatableABI, 'contractInvoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: iDelegatableABI, functionName: 'contractInvoke', ...config } as UsePrepareContractWriteConfig<
    typeof iDelegatableABI,
    'contractInvoke'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link iDelegatableABI}__ and `functionName` set to `"invoke"`.
 */
export function usePrepareIDelegatableInvoke(
  config: Omit<UsePrepareContractWriteConfig<typeof iDelegatableABI, 'invoke'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: iDelegatableABI, functionName: 'invoke', ...config } as UsePrepareContractWriteConfig<
    typeof iDelegatableABI,
    'invoke'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link erc20ABI}__.
 */
export function useErc20(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: erc20ABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__.
 */
export function useErc20Read<TFunctionName extends string, TSelectData = ReadContractResult<typeof erc20ABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, ...config } as UseContractReadConfig<typeof erc20ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"allowance"`.
 */
export function useErc20Allowance<TSelectData = ReadContractResult<typeof erc20ABI, 'allowance'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'allowance', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'allowance', ...config } as UseContractReadConfig<typeof erc20ABI, 'allowance', TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useErc20BalanceOf<TSelectData = ReadContractResult<typeof erc20ABI, 'balanceOf'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'balanceOf', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'balanceOf', ...config } as UseContractReadConfig<typeof erc20ABI, 'balanceOf', TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"decimals"`.
 */
export function useErc20Decimals<TSelectData = ReadContractResult<typeof erc20ABI, 'decimals'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'decimals', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'decimals', ...config } as UseContractReadConfig<typeof erc20ABI, 'decimals', TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"name"`.
 */
export function useErc20Name<TSelectData = ReadContractResult<typeof erc20ABI, 'name'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'name', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'name', ...config } as UseContractReadConfig<typeof erc20ABI, 'name', TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"symbol"`.
 */
export function useErc20Symbol<TSelectData = ReadContractResult<typeof erc20ABI, 'symbol'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'symbol', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'symbol', ...config } as UseContractReadConfig<typeof erc20ABI, 'symbol', TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useErc20TotalSupply<TSelectData = ReadContractResult<typeof erc20ABI, 'totalSupply'>>(
  config: Omit<UseContractReadConfig<typeof erc20ABI, 'totalSupply', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20ABI, functionName: 'totalSupply', ...config } as UseContractReadConfig<
    typeof erc20ABI,
    'totalSupply',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__.
 */
export function useErc20Write<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof erc20ABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, TFunctionName>({ abi: erc20ABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"approve"`.
 */
export function useErc20Approve<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, 'approve'>['abi'], 'approve'> & { functionName?: 'approve' }
    : UseContractWriteConfig<TMode, typeof erc20ABI, 'approve'> & {
        abi?: never
        functionName?: 'approve'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, 'approve'>({ abi: erc20ABI, functionName: 'approve', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function useErc20DecreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, 'decreaseAllowance'>['abi'], 'decreaseAllowance'> & {
        functionName?: 'decreaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof erc20ABI, 'decreaseAllowance'> & {
        abi?: never
        functionName?: 'decreaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, 'decreaseAllowance'>({ abi: erc20ABI, functionName: 'decreaseAllowance', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function useErc20IncreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, 'increaseAllowance'>['abi'], 'increaseAllowance'> & {
        functionName?: 'increaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof erc20ABI, 'increaseAllowance'> & {
        abi?: never
        functionName?: 'increaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, 'increaseAllowance'>({ abi: erc20ABI, functionName: 'increaseAllowance', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"transfer"`.
 */
export function useErc20Transfer<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, 'transfer'>['abi'], 'transfer'> & { functionName?: 'transfer' }
    : UseContractWriteConfig<TMode, typeof erc20ABI, 'transfer'> & {
        abi?: never
        functionName?: 'transfer'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, 'transfer'>({ abi: erc20ABI, functionName: 'transfer', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useErc20TransferFrom<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20ABI, 'transferFrom'>['abi'], 'transferFrom'> & {
        functionName?: 'transferFrom'
      }
    : UseContractWriteConfig<TMode, typeof erc20ABI, 'transferFrom'> & {
        abi?: never
        functionName?: 'transferFrom'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20ABI, 'transferFrom'>({ abi: erc20ABI, functionName: 'transferFrom', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__.
 */
export function usePrepareErc20Write<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ABI, ...config } as UsePrepareContractWriteConfig<typeof erc20ABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareErc20Approve(config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, 'approve'>, 'abi' | 'functionName'> = {} as any) {
  return usePrepareContractWrite({ abi: erc20ABI, functionName: 'approve', ...config } as UsePrepareContractWriteConfig<typeof erc20ABI, 'approve'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function usePrepareErc20DecreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, 'decreaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ABI, functionName: 'decreaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ABI,
    'decreaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function usePrepareErc20IncreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, 'increaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ABI, functionName: 'increaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ABI,
    'increaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareErc20Transfer(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, 'transfer'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ABI, functionName: 'transfer', ...config } as UsePrepareContractWriteConfig<typeof erc20ABI, 'transfer'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20ABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareErc20TransferFrom(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20ABI, 'transferFrom'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20ABI, functionName: 'transferFrom', ...config } as UsePrepareContractWriteConfig<
    typeof erc20ABI,
    'transferFrom'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20ABI}__.
 */
export function useErc20Event<TEventName extends string>(config: Omit<UseContractEventConfig<typeof erc20ABI, TEventName>, 'abi'> = {} as any) {
  return useContractEvent({ abi: erc20ABI, ...config } as UseContractEventConfig<typeof erc20ABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20ABI}__ and `eventName` set to `"Approval"`.
 */
export function useErc20ApprovalEvent(config: Omit<UseContractEventConfig<typeof erc20ABI, 'Approval'>, 'abi' | 'eventName'> = {} as any) {
  return useContractEvent({ abi: erc20ABI, eventName: 'Approval', ...config } as UseContractEventConfig<typeof erc20ABI, 'Approval'>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20ABI}__ and `eventName` set to `"Transfer"`.
 */
export function useErc20TransferEvent(config: Omit<UseContractEventConfig<typeof erc20ABI, 'Transfer'>, 'abi' | 'eventName'> = {} as any) {
  return useContractEvent({ abi: erc20ABI, eventName: 'Transfer', ...config } as UseContractEventConfig<typeof erc20ABI, 'Transfer'>)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link ierc20ABI}__.
 */
export function useIerc20(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: ierc20ABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20ABI}__.
 */
export function useIerc20Read<TFunctionName extends string, TSelectData = ReadContractResult<typeof ierc20ABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof ierc20ABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: ierc20ABI, ...config } as UseContractReadConfig<typeof ierc20ABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"allowance"`.
 */
export function useIerc20Allowance<TSelectData = ReadContractResult<typeof ierc20ABI, 'allowance'>>(
  config: Omit<UseContractReadConfig<typeof ierc20ABI, 'allowance', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20ABI, functionName: 'allowance', ...config } as UseContractReadConfig<
    typeof ierc20ABI,
    'allowance',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useIerc20BalanceOf<TSelectData = ReadContractResult<typeof ierc20ABI, 'balanceOf'>>(
  config: Omit<UseContractReadConfig<typeof ierc20ABI, 'balanceOf', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20ABI, functionName: 'balanceOf', ...config } as UseContractReadConfig<
    typeof ierc20ABI,
    'balanceOf',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useIerc20TotalSupply<TSelectData = ReadContractResult<typeof ierc20ABI, 'totalSupply'>>(
  config: Omit<UseContractReadConfig<typeof ierc20ABI, 'totalSupply', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20ABI, functionName: 'totalSupply', ...config } as UseContractReadConfig<
    typeof ierc20ABI,
    'totalSupply',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20ABI}__.
 */
export function useIerc20Write<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20ABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof ierc20ABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20ABI, TFunctionName>({ abi: ierc20ABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"approve"`.
 */
export function useIerc20Approve<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20ABI, 'approve'>['abi'], 'approve'> & { functionName?: 'approve' }
    : UseContractWriteConfig<TMode, typeof ierc20ABI, 'approve'> & {
        abi?: never
        functionName?: 'approve'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20ABI, 'approve'>({ abi: ierc20ABI, functionName: 'approve', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"transfer"`.
 */
export function useIerc20Transfer<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20ABI, 'transfer'>['abi'], 'transfer'> & { functionName?: 'transfer' }
    : UseContractWriteConfig<TMode, typeof ierc20ABI, 'transfer'> & {
        abi?: never
        functionName?: 'transfer'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20ABI, 'transfer'>({ abi: ierc20ABI, functionName: 'transfer', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useIerc20TransferFrom<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20ABI, 'transferFrom'>['abi'], 'transferFrom'> & {
        functionName?: 'transferFrom'
      }
    : UseContractWriteConfig<TMode, typeof ierc20ABI, 'transferFrom'> & {
        abi?: never
        functionName?: 'transferFrom'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20ABI, 'transferFrom'>({ abi: ierc20ABI, functionName: 'transferFrom', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20ABI}__.
 */
export function usePrepareIerc20Write<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20ABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20ABI, ...config } as UsePrepareContractWriteConfig<typeof ierc20ABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareIerc20Approve(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20ABI, 'approve'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20ABI, functionName: 'approve', ...config } as UsePrepareContractWriteConfig<typeof ierc20ABI, 'approve'>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareIerc20Transfer(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20ABI, 'transfer'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20ABI, functionName: 'transfer', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20ABI,
    'transfer'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20ABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareIerc20TransferFrom(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20ABI, 'transferFrom'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20ABI, functionName: 'transferFrom', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20ABI,
    'transferFrom'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20ABI}__.
 */
export function useIerc20Event<TEventName extends string>(config: Omit<UseContractEventConfig<typeof ierc20ABI, TEventName>, 'abi'> = {} as any) {
  return useContractEvent({ abi: ierc20ABI, ...config } as UseContractEventConfig<typeof ierc20ABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20ABI}__ and `eventName` set to `"Approval"`.
 */
export function useIerc20ApprovalEvent(config: Omit<UseContractEventConfig<typeof ierc20ABI, 'Approval'>, 'abi' | 'eventName'> = {} as any) {
  return useContractEvent({ abi: ierc20ABI, eventName: 'Approval', ...config } as UseContractEventConfig<typeof ierc20ABI, 'Approval'>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20ABI}__ and `eventName` set to `"Transfer"`.
 */
export function useIerc20TransferEvent(config: Omit<UseContractEventConfig<typeof ierc20ABI, 'Transfer'>, 'abi' | 'eventName'> = {} as any) {
  return useContractEvent({ abi: ierc20ABI, eventName: 'Transfer', ...config } as UseContractEventConfig<typeof ierc20ABI, 'Transfer'>)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link ierc20MetadataABI}__.
 */
export function useIerc20Metadata(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: ierc20MetadataABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__.
 */
export function useIerc20MetadataRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof ierc20MetadataABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, ...config } as UseContractReadConfig<typeof ierc20MetadataABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"allowance"`.
 */
export function useIerc20MetadataAllowance<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'allowance'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'allowance', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'allowance', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'allowance',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useIerc20MetadataBalanceOf<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'balanceOf'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'balanceOf', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'balanceOf', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'balanceOf',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"decimals"`.
 */
export function useIerc20MetadataDecimals<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'decimals'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'decimals', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'decimals', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'decimals',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"name"`.
 */
export function useIerc20MetadataName<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'name'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'name', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'name', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'name',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"symbol"`.
 */
export function useIerc20MetadataSymbol<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'symbol'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'symbol', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'symbol', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'symbol',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useIerc20MetadataTotalSupply<TSelectData = ReadContractResult<typeof ierc20MetadataABI, 'totalSupply'>>(
  config: Omit<UseContractReadConfig<typeof ierc20MetadataABI, 'totalSupply', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20MetadataABI, functionName: 'totalSupply', ...config } as UseContractReadConfig<
    typeof ierc20MetadataABI,
    'totalSupply',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__.
 */
export function useIerc20MetadataWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20MetadataABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof ierc20MetadataABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20MetadataABI, TFunctionName>({ abi: ierc20MetadataABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"approve"`.
 */
export function useIerc20MetadataApprove<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20MetadataABI, 'approve'>['abi'], 'approve'> & { functionName?: 'approve' }
    : UseContractWriteConfig<TMode, typeof ierc20MetadataABI, 'approve'> & {
        abi?: never
        functionName?: 'approve'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20MetadataABI, 'approve'>({ abi: ierc20MetadataABI, functionName: 'approve', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"transfer"`.
 */
export function useIerc20MetadataTransfer<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20MetadataABI, 'transfer'>['abi'], 'transfer'> & {
        functionName?: 'transfer'
      }
    : UseContractWriteConfig<TMode, typeof ierc20MetadataABI, 'transfer'> & {
        abi?: never
        functionName?: 'transfer'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20MetadataABI, 'transfer'>({ abi: ierc20MetadataABI, functionName: 'transfer', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useIerc20MetadataTransferFrom<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20MetadataABI, 'transferFrom'>['abi'], 'transferFrom'> & {
        functionName?: 'transferFrom'
      }
    : UseContractWriteConfig<TMode, typeof ierc20MetadataABI, 'transferFrom'> & {
        abi?: never
        functionName?: 'transferFrom'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20MetadataABI, 'transferFrom'>({ abi: ierc20MetadataABI, functionName: 'transferFrom', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__.
 */
export function usePrepareIerc20MetadataWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20MetadataABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20MetadataABI, ...config } as UsePrepareContractWriteConfig<typeof ierc20MetadataABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareIerc20MetadataApprove(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20MetadataABI, 'approve'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20MetadataABI, functionName: 'approve', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20MetadataABI,
    'approve'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareIerc20MetadataTransfer(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20MetadataABI, 'transfer'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20MetadataABI, functionName: 'transfer', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20MetadataABI,
    'transfer'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20MetadataABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareIerc20MetadataTransferFrom(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20MetadataABI, 'transferFrom'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20MetadataABI, functionName: 'transferFrom', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20MetadataABI,
    'transferFrom'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20MetadataABI}__.
 */
export function useIerc20MetadataEvent<TEventName extends string>(
  config: Omit<UseContractEventConfig<typeof ierc20MetadataABI, TEventName>, 'abi'> = {} as any
) {
  return useContractEvent({ abi: ierc20MetadataABI, ...config } as UseContractEventConfig<typeof ierc20MetadataABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20MetadataABI}__ and `eventName` set to `"Approval"`.
 */
export function useIerc20MetadataApprovalEvent(
  config: Omit<UseContractEventConfig<typeof ierc20MetadataABI, 'Approval'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: ierc20MetadataABI, eventName: 'Approval', ...config } as UseContractEventConfig<
    typeof ierc20MetadataABI,
    'Approval'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link ierc20MetadataABI}__ and `eventName` set to `"Transfer"`.
 */
export function useIerc20MetadataTransferEvent(
  config: Omit<UseContractEventConfig<typeof ierc20MetadataABI, 'Transfer'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: ierc20MetadataABI, eventName: 'Transfer', ...config } as UseContractEventConfig<
    typeof ierc20MetadataABI,
    'Transfer'
  >)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link erc20PermitABI}__.
 */
export function useErc20Permit(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: erc20PermitABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__.
 */
export function useErc20PermitRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof erc20PermitABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, ...config } as UseContractReadConfig<typeof erc20PermitABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"DOMAIN_SEPARATOR"`.
 */
export function useErc20PermitDomainSeparator<TSelectData = ReadContractResult<typeof erc20PermitABI, 'DOMAIN_SEPARATOR'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'DOMAIN_SEPARATOR', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'DOMAIN_SEPARATOR', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'DOMAIN_SEPARATOR',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"allowance"`.
 */
export function useErc20PermitAllowance<TSelectData = ReadContractResult<typeof erc20PermitABI, 'allowance'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'allowance', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'allowance', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'allowance',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"balanceOf"`.
 */
export function useErc20PermitBalanceOf<TSelectData = ReadContractResult<typeof erc20PermitABI, 'balanceOf'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'balanceOf', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'balanceOf', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'balanceOf',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"decimals"`.
 */
export function useErc20PermitDecimals<TSelectData = ReadContractResult<typeof erc20PermitABI, 'decimals'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'decimals', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'decimals', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'decimals',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"name"`.
 */
export function useErc20PermitName<TSelectData = ReadContractResult<typeof erc20PermitABI, 'name'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'name', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'name', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'name',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"nonces"`.
 */
export function useErc20PermitNonces<TSelectData = ReadContractResult<typeof erc20PermitABI, 'nonces'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'nonces', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'nonces', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'nonces',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"symbol"`.
 */
export function useErc20PermitSymbol<TSelectData = ReadContractResult<typeof erc20PermitABI, 'symbol'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'symbol', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'symbol', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'symbol',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"totalSupply"`.
 */
export function useErc20PermitTotalSupply<TSelectData = ReadContractResult<typeof erc20PermitABI, 'totalSupply'>>(
  config: Omit<UseContractReadConfig<typeof erc20PermitABI, 'totalSupply', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: erc20PermitABI, functionName: 'totalSupply', ...config } as UseContractReadConfig<
    typeof erc20PermitABI,
    'totalSupply',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__.
 */
export function useErc20PermitWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, TFunctionName>({ abi: erc20PermitABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"approve"`.
 */
export function useErc20PermitApprove<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'approve'>['abi'], 'approve'> & { functionName?: 'approve' }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'approve'> & {
        abi?: never
        functionName?: 'approve'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'approve'>({ abi: erc20PermitABI, functionName: 'approve', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function useErc20PermitDecreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'decreaseAllowance'>['abi'], 'decreaseAllowance'> & {
        functionName?: 'decreaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'decreaseAllowance'> & {
        abi?: never
        functionName?: 'decreaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'decreaseAllowance'>({
    abi: erc20PermitABI,
    functionName: 'decreaseAllowance',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function useErc20PermitIncreaseAllowance<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'increaseAllowance'>['abi'], 'increaseAllowance'> & {
        functionName?: 'increaseAllowance'
      }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'increaseAllowance'> & {
        abi?: never
        functionName?: 'increaseAllowance'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'increaseAllowance'>({
    abi: erc20PermitABI,
    functionName: 'increaseAllowance',
    ...config,
  } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"permit"`.
 */
export function useErc20PermitPermit<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'permit'>['abi'], 'permit'> & { functionName?: 'permit' }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'permit'> & {
        abi?: never
        functionName?: 'permit'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'permit'>({ abi: erc20PermitABI, functionName: 'permit', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"transfer"`.
 */
export function useErc20PermitTransfer<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'transfer'>['abi'], 'transfer'> & { functionName?: 'transfer' }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'transfer'> & {
        abi?: never
        functionName?: 'transfer'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'transfer'>({ abi: erc20PermitABI, functionName: 'transfer', ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"transferFrom"`.
 */
export function useErc20PermitTransferFrom<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof erc20PermitABI, 'transferFrom'>['abi'], 'transferFrom'> & {
        functionName?: 'transferFrom'
      }
    : UseContractWriteConfig<TMode, typeof erc20PermitABI, 'transferFrom'> & {
        abi?: never
        functionName?: 'transferFrom'
      } = {} as any
) {
  return useContractWrite<TMode, typeof erc20PermitABI, 'transferFrom'>({ abi: erc20PermitABI, functionName: 'transferFrom', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__.
 */
export function usePrepareErc20PermitWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, ...config } as UsePrepareContractWriteConfig<typeof erc20PermitABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"approve"`.
 */
export function usePrepareErc20PermitApprove(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'approve'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'approve', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'approve'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"decreaseAllowance"`.
 */
export function usePrepareErc20PermitDecreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'decreaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'decreaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'decreaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"increaseAllowance"`.
 */
export function usePrepareErc20PermitIncreaseAllowance(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'increaseAllowance'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'increaseAllowance', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'increaseAllowance'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"permit"`.
 */
export function usePrepareErc20PermitPermit(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'permit'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'permit', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'permit'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"transfer"`.
 */
export function usePrepareErc20PermitTransfer(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'transfer'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'transfer', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'transfer'
  >)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link erc20PermitABI}__ and `functionName` set to `"transferFrom"`.
 */
export function usePrepareErc20PermitTransferFrom(
  config: Omit<UsePrepareContractWriteConfig<typeof erc20PermitABI, 'transferFrom'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: erc20PermitABI, functionName: 'transferFrom', ...config } as UsePrepareContractWriteConfig<
    typeof erc20PermitABI,
    'transferFrom'
  >)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20PermitABI}__.
 */
export function useErc20PermitEvent<TEventName extends string>(
  config: Omit<UseContractEventConfig<typeof erc20PermitABI, TEventName>, 'abi'> = {} as any
) {
  return useContractEvent({ abi: erc20PermitABI, ...config } as UseContractEventConfig<typeof erc20PermitABI, TEventName>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20PermitABI}__ and `eventName` set to `"Approval"`.
 */
export function useErc20PermitApprovalEvent(
  config: Omit<UseContractEventConfig<typeof erc20PermitABI, 'Approval'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: erc20PermitABI, eventName: 'Approval', ...config } as UseContractEventConfig<typeof erc20PermitABI, 'Approval'>)
}

/**
 * Wraps __{@link useContractEvent}__ with `abi` set to __{@link erc20PermitABI}__ and `eventName` set to `"Transfer"`.
 */
export function useErc20PermitTransferEvent(
  config: Omit<UseContractEventConfig<typeof erc20PermitABI, 'Transfer'>, 'abi' | 'eventName'> = {} as any
) {
  return useContractEvent({ abi: erc20PermitABI, eventName: 'Transfer', ...config } as UseContractEventConfig<typeof erc20PermitABI, 'Transfer'>)
}

/**
 * Wraps __{@link useContract}__ with `abi` set to __{@link ierc20PermitABI}__.
 */
export function useIerc20Permit(config: Omit<UseContractConfig, 'abi'> = {} as any) {
  return useContract({ abi: ierc20PermitABI, ...config })
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20PermitABI}__.
 */
export function useIerc20PermitRead<TFunctionName extends string, TSelectData = ReadContractResult<typeof ierc20PermitABI, TFunctionName>>(
  config: Omit<UseContractReadConfig<typeof ierc20PermitABI, TFunctionName, TSelectData>, 'abi'> = {} as any
) {
  return useContractRead({ abi: ierc20PermitABI, ...config } as UseContractReadConfig<typeof ierc20PermitABI, TFunctionName, TSelectData>)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20PermitABI}__ and `functionName` set to `"DOMAIN_SEPARATOR"`.
 */
export function useIerc20PermitDomainSeparator<TSelectData = ReadContractResult<typeof ierc20PermitABI, 'DOMAIN_SEPARATOR'>>(
  config: Omit<UseContractReadConfig<typeof ierc20PermitABI, 'DOMAIN_SEPARATOR', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20PermitABI, functionName: 'DOMAIN_SEPARATOR', ...config } as UseContractReadConfig<
    typeof ierc20PermitABI,
    'DOMAIN_SEPARATOR',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractRead}__ with `abi` set to __{@link ierc20PermitABI}__ and `functionName` set to `"nonces"`.
 */
export function useIerc20PermitNonces<TSelectData = ReadContractResult<typeof ierc20PermitABI, 'nonces'>>(
  config: Omit<UseContractReadConfig<typeof ierc20PermitABI, 'nonces', TSelectData>, 'abi' | 'functionName'> = {} as any
) {
  return useContractRead({ abi: ierc20PermitABI, functionName: 'nonces', ...config } as UseContractReadConfig<
    typeof ierc20PermitABI,
    'nonces',
    TSelectData
  >)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20PermitABI}__.
 */
export function useIerc20PermitWrite<TMode extends WriteContractMode, TFunctionName extends string>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20PermitABI, string>['abi'], TFunctionName>
    : UseContractWriteConfig<TMode, typeof ierc20PermitABI, TFunctionName> & {
        abi?: never
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20PermitABI, TFunctionName>({ abi: ierc20PermitABI, ...config } as any)
}

/**
 * Wraps __{@link useContractWrite}__ with `abi` set to __{@link ierc20PermitABI}__ and `functionName` set to `"permit"`.
 */
export function useIerc20PermitPermit<TMode extends WriteContractMode>(
  config: TMode extends 'prepared'
    ? UseContractWriteConfig<TMode, PrepareWriteContractResult<typeof ierc20PermitABI, 'permit'>['abi'], 'permit'> & { functionName?: 'permit' }
    : UseContractWriteConfig<TMode, typeof ierc20PermitABI, 'permit'> & {
        abi?: never
        functionName?: 'permit'
      } = {} as any
) {
  return useContractWrite<TMode, typeof ierc20PermitABI, 'permit'>({ abi: ierc20PermitABI, functionName: 'permit', ...config } as any)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20PermitABI}__.
 */
export function usePrepareIerc20PermitWrite<TFunctionName extends string>(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20PermitABI, TFunctionName>, 'abi'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20PermitABI, ...config } as UsePrepareContractWriteConfig<typeof ierc20PermitABI, TFunctionName>)
}

/**
 * Wraps __{@link usePrepareContractWrite}__ with `abi` set to __{@link ierc20PermitABI}__ and `functionName` set to `"permit"`.
 */
export function usePrepareIerc20PermitPermit(
  config: Omit<UsePrepareContractWriteConfig<typeof ierc20PermitABI, 'permit'>, 'abi' | 'functionName'> = {} as any
) {
  return usePrepareContractWrite({ abi: ierc20PermitABI, functionName: 'permit', ...config } as UsePrepareContractWriteConfig<
    typeof ierc20PermitABI,
    'permit'
  >)
}
